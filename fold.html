% if (!$algorithm or !$input_fasta) {

Use this form to fold a _short_ sequence.<br>
<FORM action="fold.html" enctype="multipart/form-data" method="POST">
<input type="file" name="input_fasta">
<select name="algorithm">
<option selected="selected" value="nupack">Nupack</option>
<option value="pknots">Pknots</option>
<option value="hotknots">HotKnots</option>
<option value="rnafold">RNAfold</option>
<option value="mfold">mfold</option>
<option value="all">all</option>
</select> 
<input type="submit" name="fold submit" value="Fold">
</form>

% } else {

<%perl>
use Apache2::Upload;
my $req = new Apache2::Request($r);
my $upload = $req->upload("input_fasta");
my $upload_filename = $upload->filename();
my $contents;
my $size = $upload->slurp($contents);
my $tempfile_fh = new File::Temp(DIR => "$config->{base}/folds", UNLINK=>0);
my $new_filename = $tempfile_fh->filename();
my $short_filename = $new_filename;
my @fun = split(/\//, $short_filename);
$short_filename = $fun[$#fun];
print $tempfile_fh $contents;
close $tempfile_fh;

print "TESTME: $size $upload_filename $new_filename $short_filename
<pre>
$contents
</pre>\n";
print $contents;
my $new_url = "folds/$short_filename.html";

sub tmp_fold {
  my $config = shift;
  my $new_filename = shift;
  my $input_path = "$config->{base}/folds/$new_filename";
  print STDERR "This is filename: $new_filename\n";
  my $fold = new RNAFolders(config => $config, file => $input_path, genome_id => 0, species => 'saccharomyces_cerevisiae', accession => 2, start => 0,);
  # my $nupack_mfe_info = $fold->Pknots('nopseudo');
  my $nupack_mfe_info = $fold->Nupack_NOPAIRS();
  my $mfe = $nupack_mfe_info->{mfe};
  print STDERR "THIS IS THE MFE: $mfe\n";
  my $parsed = $nupack_mfe_info->{parsed};
  my $barcode = $nupack_mfe_info->{barcode};
  my $output = $nupack_mfe_info->{output};
  my $pairs = $nupack_mfe_info->{pairs};
  my $sequence = $nupack_mfe_info->{sequence};
  my $pic_output = "$config->{base}/folds/$new_filename.svg";
  my $feynman_pic = new PRFGraph({sequence=>$sequence, parsed => $parsed, output => $output});
  my $dimensions = $feynman_pic->Make_Feynman($pic_output, 0);
#  use IO::Handle;
#  sysopen(HANDLE, "$new_filename.html", "O_RDWR|O_CREAT|O_EXCL") or die "sysopen $new_filename: $!";
#  my $oldfh = select(HANDLE); $| = 1; select $oldfh;
  open (HANDLE, ">$input_path.html") or die("Cannot open HANDLE $new_filename.html $!");
  print HANDLE qq(TESTME: $mfe<br>
 $output<br>
<embed id=\"feynman\" src=\"$new_filename.svg\" align=\"bottom\"></embed>);
  close(HANDLE);
}
use Proc::Forkfunc;
my @child_args = ($config, $short_filename);
forkfunc(\&tmp_fold, @child_args);
</%perl>

<p>This should redirect you to the output page for your folding.</p>
<script language="JavaScript">
var sURL = "<% "folds/$short_filename.html" %>";
function doLoad()
{
    setTimeout( "refresh()", 1*1000 );
}

function refresh()
{
    //  This version of the refresh function will cause a new
    //  entry in the visitor's history.  It is provided for
    //  those browsers that only support JavaScript 1.0.
    //
    window.location.href = sURL;
}
//-->
</script>

<script language="JavaScript1.1">
<!--
function refresh()
{
    //  This version does NOT cause an entry in the browser's
    //  page view history.  Most browsers will always retrieve
    //  the document from the web-server whether it is already
    //  in the browsers page-cache or not.
    //  
    window.location.replace( sURL );
}
//-->
</script>


% }

<%init>
  my $tempfile;
  my $new_filename;
</%init>
<%args>
  $algorithm => undef
  $input_fasta => undef
</%args>